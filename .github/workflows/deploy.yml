# .github/workflows/deploy.yml 


name: Deploy to Production 

on: 
#   workflow_dispatch: {} # Allows manual triggering of the workflow
#   workflow_run:
#     workflows: 
#       - "Static Code Analysis"
     
#     types:
#       - completed 

  push: 
    branches: [main] # Trigger on push to main branch
  pull_request:
    branches: [main] # Trigger on pull request to main branch 


jobs: 
    build-web: 
        runs-on: ubuntu-latest 

        steps: 
        -   name: Checkout code
            uses: actions/checkout@v4

        -   name: Build web
            working-directory: web
            run: npm ci && npm run build

        -   name: sanity check to check if the build is successful
            run: test -d web/dist || (echo "Build failed, web.dist directory not found!" && exit 1) 

    build-and-push-images:
        needs: build-web
        runs-on: ubuntu-latest
        env: 
            DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }} # Your Docker Hub username 
            DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }} # Your Docker Hub token for authentication 
        steps:

        -   uses: actions/checkout@v4

        -   name: Build & push via Compose 
            run: |
                echo "→ Logging in to Docker Hub as ${{ secrets.DOCKERHUB_USERNAME }}"
                docker login docker.io -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_TOKEN }}
                
                echo "→ Building all services"
                docker compose build

                echo "→ Pushing images to docker.io"
                docker compose push

                echo "✅ Build & push complete"     

    deploy:
        runs-on: ubuntu-latest
        needs: build-and-push-images # Ensure the build job is completed before deploying 


        env: 
            #.env
            FLASK_RUN_HOST: ${{ secrets.FLASK_RUN_HOST }} # Set your Flask run host 
            FLASK_RUN_PORT: ${{ secrets.FLASK_RUN_PORT }} # Set your Flask run port 
            FLASK_SECRET: ${{ secrets.FLASK_SECRET }} # Set your Flask secret key 
            VITE_HCAPTCHA_SITEKEY: ${{ secrets.VITE_HCAPTCHA_SITEKEY }} # Set your hCaptcha site key 
            MYSQL_ROOT_PASSWORD_DEV: ${{ secrets.MYSQL_ROOT_PASSWORD_DEV }} # Set your MySQL root password for development 
            MYSQL_DATABASE_DEV: ${{ secrets.MYSQL_DATABASE_DEV }} # Set your MySQL database name for development 
            MYSQL_USER_DEV: ${{ secrets.MYSQL_USER_DEV }} # Set your MySQL user for development
            MYSQL_PASSWORD_DEV: ${{ secrets.MYSQL_PASSWORD_DEV }} # Set your MySQL password for development 
            FERNET_KEY: ${{ secrets.FERNET_KEY }} # Set your Fernet key for encryption 
            JWT_SECRET: ${{ secrets.JWT_SECRET }} # Set your JWT secret for authentication
            HCAPTCHA_SECRET: ${{ secrets.HCAPTCHA_SECRET }} # Set your hCaptcha secret key 
            AES_GCM_KEY: ${{secrets.AES_GCM_KEY}}
            
            #.env.prod , some keys added a _PROD as it shares the same name as development keys
            MYSQL_ROOT_PASSWORD_PROD: ${{ secrets.MYSQL_ROOT_PASSWORD_PROD }} # Set your MySQL root password for production
            MYSQL_DATABASE_PROD: ${{ secrets.MYSQL_DATABASE_PROD }} # Set your MySQL database name for production
            MYSQL_USER_PROD: ${{ secrets.MYSQL_USER_PROD }} # Set your MySQL user for production
            MYSQL_PASSWORD_PROD: ${{ secrets.MYSQL_PASSWORD_PROD }} # Set your MySQL password for production
            FLASK_DEBUG_PROD: ${{ secrets.FLASK_DEBUG_PROD }} # Set your Flask debug mode for production
            MYSQL_CONTAINER_NAME: ${{ secrets.MYSQL_CONTAINER_NAME }} # Set your MySQL container name for production
            MYSQL_CONTAINER_PORT: ${{ secrets.MYSQL_CONTAINER_PORT }} # Set your MySQL container port for production
            USE_SSH_TUNNEL_PROD: ${{ secrets.USE_SSH_TUNNEL_PROD }} # Set whether to use SSH tunnel for production
            SPLUNK_HEC_TOKEN: ${{ secrets.SPLUNK_HEC_TOKEN }}
            SPLUNK_SOURCE: ${{ secrets.SPLUNK_SOURCE }} # Set your Splunk source for logging
            SPLUNK_SOURCETYPE: ${{ secrets.SPLUNK_SOURCETYPE }} # Set your Splunk sourcetype for logging 
            SPLUNK_PASSWORD: ${{ secrets.SPLUNK_PASSWORD }} # Set your Splunk password for logging
            SPLUNK_IP_WHITELIST: ${{ secrets.SPLUNK_IP_WHITELIST }} # Set your Splunk IP whitelist for security 
        
            # FIREBASE secrets 
            FIREBASE_SECRET_JSON: ${{ secrets.FIREBASE_SECRET_JSON }}

        steps: 
            -   name: start SSH agent 
                uses: webfactory/ssh-agent@v0.5.4
                with:
                    ssh-private-key: ${{ secrets.EC2_SSH_KEY }} # Your SSH private key stored in GitHub Secrets 

            -   name: Add EC2 to known hosts 
                run: | 
                    ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts 


            -   name: Copy prod compose & nginx script
                run: |
                    scp -o StrictHostKeyChecking=no \
                    docker-compose.prod.yml \
                    nginx-startup.sh \
                    ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/home/${{ secrets.SSH_USER }}/ConnectIT3/

            # Generate .env files on EC2 
            -   name: Generate .env files on EC2
                run: |
                    ssh -p "$SSH_PORT" -o StrictHostKeyChecking=no "$SSH_USER@$SSH_HOST" <<EOF
                    # ─── .env ─────────────────────────────────────
                    cat > /home/$SSH_USER/ConnectIT3/.env <<E1
                    FLASK_RUN_HOST=$FLASK_RUN_HOST
                    FLASK_RUN_PORT=$FLASK_RUN_PORT
                    FLASK_SECRET=$FLASK_SECRET 
                    VITE_HCAPTCHA_SITEKEY=$VITE_HCAPTCHA_SITEKEY
                    MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD_DEV
                    MYSQL_DATABASE=$MYSQL_DATABASE_DEV
                    MYSQL_USER=$MYSQL_USER_DEV
                    MYSQL_PASSWORD=$MYSQL_PASSWORD_DEV          
                    FERNET_KEY=$FERNET_KEY
                    JWT_SECRET=$JWT_SECRET
                    HCAPTCHA_SECRET=$HCAPTCHA_SECRET
                    AES_GCM_KEY=$AES_GCM_KEY
                    E1

                    # ─── connectit-63f60-firebase-adminsdk-fbsvc-c106a0e591.json ───────────(Commented out)──────────────────────
                    cat > /home/$SSH_USER/ConnectIT3/connectit-63f60-firebase-adminsdk-fbsvc-c106a0e591.json <<E2
                    $FIREBASE_SECRET_JSON
                    E2

                    # ─── .env.prod ────────────────────────────────
                    cat > /home/$SSH_USER/ConnectIT3/.env.prod <<E3
                    MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD_PROD
                    MYSQL_DATABASE=$MYSQL_DATABASE_PROD
                    MYSQL_USER=$MYSQL_USER_PROD
                    MYSQL_PASSWORD=$MYSQL_PASSWORD_PROD
                    FLASK_DEBUG=$FLASK_DEBUG_PROD
                    MYSQL_CONTAINER_NAME=$MYSQL_CONTAINER_NAME
                    MYSQL_CONTAINER_PORT=$MYSQL_CONTAINER_PORT
                    USE_SSH_TUNNEL=$USE_SSH_TUNNEL_PROD

                        
                    SPLUNK_HEC_TOKEN=$SPLUNK_HEC_TOKEN
                    SPLUNK_SOURCE=$SPLUNK_SOURCE
                    SPLUNK_SOURCETYPE=$SPLUNK_SOURCETYPE
                    SPLUNK_PASSWORD=$SPLUNK_PASSWORD
                    SPLUNK_IP_WHITELIST=$SPLUNK_IP_WHITELIST 
                    E3
                    EOF
        
#   deploy: 
#     runs-on: ubuntu-latest 
#     needs: build-and-push-images # Ensure the build job is completed before deploying 

#     env: 
#       #.env
#       FLASK_RUN_HOST: ${{ secrets.FLASK_RUN_HOST }} # Set your Flask run host 
#       FLASK_RUN_PORT: ${{ secrets.FLASK_RUN_PORT }} # Set your Flask run port 
#       FLASK_SECRET: ${{ secrets.FLASK_SECRET }} # Set your Flask secret key 
#       VITE_HCAPTCHA_SITEKEY: ${{ secrets.VITE_HCAPTCHA_SITEKEY }} # Set your hCaptcha site key 
#       MYSQL_ROOT_PASSWORD_DEV: ${{ secrets.MYSQL_ROOT_PASSWORD_DEV }} # Set your MySQL root password for development 
#       MYSQL_DATABASE_DEV: ${{ secrets.MYSQL_DATABASE_DEV }} # Set your MySQL database name for development 
#       MYSQL_USER_DEV: ${{ secrets.MYSQL_USER_DEV }} # Set your MySQL user for development
#       MYSQL_PASSWORD_DEV: ${{ secrets.MYSQL_PASSWORD_DEV }} # Set your MySQL password for development 
#       FERNET_KEY: ${{ secrets.FERNET_KEY }} # Set your Fernet key for encryption 
#       JWT_SECRET: ${{ secrets.JWT_SECRET }} # Set your JWT secret for authentication
#       HCAPTCHA_SECRET: ${{ secrets.HCAPTCHA_SECRET }} # Set your hCaptcha secret key 
#       AES_GCM_KEY: ${{secrets.AES_GCM_KEY}}
      
#       #.env.dev , some keys added a _DEV as it shares the same name as production keys 
#       MYSQL_REMOTE_PORT : ${{ secrets.MYSQL_REMOTE_PORT }} # Set your MySQL remote port 
#       FLASK_DEBUG_DEV: ${{ secrets.FLASK_DEBUG_DEV }} # Set your Flask debug mode 
#       USE_SSH_TUNNEL_DEV : ${{ secrets.USE_SSH_TUNNEL_DEV }} # Set whether to use SSH tunnel for development 
#       SSH_HOST: ${{ secrets.SSH_HOST }} # Set your SSH host 
#       SSH_PORT: ${{ secrets.SSH_PORT }} # Set your SSH port 
#       SSH_USER: ${{ secrets.SSH_USER }} # Set your SSH user 
#       PEM_FILE: ${{ secrets.PEM_FILE }} # Set your PEM file for SSH access 
#       ENCRYPTED_TOTP_SECRET: ${{ secrets.ENCRYPTED_TOTP_SECRET }} #! for testing so probably put it in the workflow file that does the playwright test!
      
#       #.env.prod , some keys added a _PROD as it shares the same name as development keys
#       MYSQL_ROOT_PASSWORD_PROD: ${{ secrets.MYSQL_ROOT_PASSWORD_PROD }} # Set your MySQL root password for production
#       MYSQL_DATABASE_PROD: ${{ secrets.MYSQL_DATABASE_PROD }} # Set your MySQL database name for production
#       MYSQL_USER_PROD: ${{ secrets.MYSQL_USER_PROD }} # Set your MySQL user for production
#       MYSQL_PASSWORD_PROD: ${{ secrets.MYSQL_PASSWORD_PROD }} # Set your MySQL password for production
#       FLASK_DEBUG_PROD: ${{ secrets.FLASK_DEBUG_PROD }} # Set your Flask debug mode for production
#       MYSQL_CONTAINER_NAME: ${{ secrets.MYSQL_CONTAINER_NAME }} # Set your MySQL container name for production
#       MYSQL_CONTAINER_PORT: ${{ secrets.MYSQL_CONTAINER_PORT }} # Set your MySQL container port for production
#       USE_SSH_TUNNEL_PROD: ${{ secrets.USE_SSH_TUNNEL_PROD }} # Set whether to use SSH tunnel for production
#       SPLUNK_HEC_TOKEN: ${{ secrets.SPLUNK_HEC_TOKEN }}
#       SPLUNK_SOURCE: ${{ secrets.SPLUNK_SOURCE }} # Set your Splunk source for logging
#       SPLUNK_SOURCETYPE: ${{ secrets.SPLUNK_SOURCETYPE }} # Set your Splunk sourcetype for logging 
#       SPLUNK_PASSWORD: ${{ secrets.SPLUNK_PASSWORD }} # Set your Splunk password for logging
#       SPLUNK_IP_WHITELIST: ${{ secrets.SPLUNK_IP_WHITELIST }} # Set your Splunk IP whitelist for security 


#       # FIREBASE secrets 
#       FIREBASE_SECRET_JSON: ${{ secrets.FIREBASE_SECRET_JSON }}

#     steps: 
#       - name: Checkout code 
#         uses: actions/checkout@v4
      
#       - name: start SSH agent 
#         uses: webfactory/ssh-agent@v0.5.4
#         with:
#           ssh-private-key: ${{ secrets.EC2_SSH_KEY }} # Your SSH private key stored in GitHub Secrets 

#       - name: Add EC2 to known hosts 
#         run: | 
#           ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts 
      

#       - name: Sync full ConnectIT directory to EC2
#         run: |
#           rsync -avz \
#             --exclude 'docker-compose.dev.*' \
#             --exclude 'pytest.ini' \
#             --exclude '.flake8' \
#             --exclude '/tests' \
#             --exclude '.gitignore' \
#             --exclude '.github/workflows' \
#             --exclude 'nginx-reverse-proxy.conf' \
#             -e "ssh -o StrictHostKeyChecking=no" \
#             . \
#             ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/home/${{ secrets.SSH_USER }}/ConnectIT3/
      


#       # Generate .env files on EC2 
#       - name: Generate .env files on EC2
#         run: |
#           ssh -p "$SSH_PORT" -o StrictHostKeyChecking=no "$SSH_USER@$SSH_HOST" <<EOF
#           # ─── .env ─────────────────────────────────────
#           cat > /home/$SSH_USER/ConnectIT/.env <<E1
#           FLASK_RUN_HOST=$FLASK_RUN_HOST
#           FLASK_RUN_PORT=$FLASK_RUN_PORT
#           FLASK_SECRET=$FLASK_SECRET 
#           VITE_HCAPTCHA_SITEKEY=$VITE_HCAPTCHA_SITEKEY
#           MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD_DEV
#           MYSQL_DATABASE=$MYSQL_DATABASE_DEV
#           MYSQL_USER=$MYSQL_USER_DEV
#           MYSQL_PASSWORD=$MYSQL_PASSWORD_DEV          
#           FERNET_KEY=$FERNET_KEY
#           JWT_SECRET=$JWT_SECRET
#           HCAPTCHA_SECRET=$HCAPTCHA_SECRET
#           AES_GCM_KEY=$AES_GCM_KEY
#           E1

#           # ─── connectit-63f60-firebase-adminsdk-fbsvc-c106a0e591.json ───────────(Commented out)──────────────────────
#           cat > /home/$SSH_USER/ConnectIT/connectit-63f60-firebase-adminsdk-fbsvc-c106a0e591.json <<E2
#           $FIREBASE_SECRET_JSON
#           E2

#           # ─── .env.prod ────────────────────────────────
#           cat > /home/$SSH_USER/ConnectIT/.env.prod <<E3
#           MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD_PROD
#           MYSQL_DATABASE=$MYSQL_DATABASE_PROD
#           MYSQL_USER=$MYSQL_USER_PROD
#           MYSQL_PASSWORD=$MYSQL_PASSWORD_PROD
#           FLASK_DEBUG=$FLASK_DEBUG_PROD
#           MYSQL_CONTAINER_NAME=$MYSQL_CONTAINER_NAME
#           MYSQL_CONTAINER_PORT=$MYSQL_CONTAINER_PORT
#           USE_SSH_TUNNEL=$USE_SSH_TUNNEL_PROD

              
#           SPLUNK_HEC_TOKEN=$SPLUNK_HEC_TOKEN
#           SPLUNK_SOURCE=$SPLUNK_SOURCE
#           SPLUNK_SOURCETYPE=$SPLUNK_SOURCETYPE
#           SPLUNK_PASSWORD=$SPLUNK_PASSWORD
#           SPLUNK_IP_WHITELIST=$SPLUNK_IP_WHITELIST 
#           E3
#           EOF

#       # Deploy to EC2
#       - name: Deploy to EC2 via SSH
#         run: |
#           ssh -t -p "$SSH_PORT" -o StrictHostKeyChecking=no "$SSH_USER@$SSH_HOST" <<-EOF
#             cd /home/$SSH_USER/ConnectIT


#             sudo docker system prune --all --volumes --force
#             sudo docker builder prune --all --force

#             sudo docker compose -f docker-compose.yaml -f docker-compose.prod.yaml up --build -d 
            
#           EOF
